/**
 * @module useBongoCat
 * @description Custom hook for BongoCat component event handling and positioning
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - export function useBongoCat( (line 45)
 *   - if (containerRef && containerRef.current) (line 58)
 *   - if (viewportWidth <= 768) (line 68)
 *   - setContainerTop(optimalTop); (line 73)
 *   - setCatSize(baseSize * scaleFactor * mobileScaleFactor); (line 81)
 *   - setIsVisible(rect.top < viewportHeight); (line 84)
 *   - setContainerZIndex(containerZ); (line 94)
 *   - if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey) (line 100)
 *   - if (now - lastKeyTimeRef.current > 1000) (line 105)
 *   - setIsPawsDown(true); (line 111)
 *   - if (!isPawsDown && onBongo) (line 114)
 *   - onBongo(); (line 115)
 *   - if (keysHeldRef.current.size === 0) (line 126)
 *   - setIsPawsDown(false); (line 127)
 *   - useEffect(() => (line 132)
 *   - if (containerRef && containerRef.current) (line 137)
 *   - updatePosition(); (line 142)
 *   - const handleScroll = () => (line 145)
 *   - requestAnimationFrame(updatePosition); (line 146)
 *   - return () => (line 165)
 *   - if (resizeObserverRef.current) (line 166)
 *   - return () => (line 178)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

import { useCallback, useEffect, useRef, useState } from "react";

/**
 * Custom hook for BongoCat component functionality
 * @param {Object} options - Hook options
 * @param {Object} options.containerRef - Reference to the container element
 * @param {number} options.size - Base size of the cat
 * @param {Function} options.onBongo - Callback when cat is bongoed
 * @returns {Object} Hook state and handlers
 */
export function useBongoCat({ containerRef, size, onBongo }) {
  const [isPawsDown, setIsPawsDown] = useState(false);
  const [containerTop, setContainerTop] = useState(0);
  const [catSize, setCatSize] = useState(size);
  const [isVisible, setIsVisible] = useState(true);
  const [containerZIndex, setContainerZIndex] = useState(0);

  const lastKeyTimeRef = useRef(0);
  const keysHeldRef = useRef(new Set());
  const resizeObserverRef = useRef(null);

  // Calculate position based on container position with debouncing
  const updatePosition = useCallback(() => {
    if (containerRef && containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      const viewportWidth = window.innerWidth;
      const containerWidth = rect.width;

      // Try to find a form element within the container to position relative to it
      const formElement = containerRef.current.querySelector('form');
      let optimalTop = 19; // Default position near top

      if (formElement) {
        // Position cat relative to the form - slightly above it
        const formRect = formElement.getBoundingClientRect();
        const containerRect = containerRef.current.getBoundingClientRect();
        // Calculate position relative to container
        optimalTop = (formRect.top - containerRect.top) - 60; // 60px above the form
        // Ensure it's not too high (minimum 19px from top)
        optimalTop = Math.max(19, optimalTop);
      } else {
        // Fallback: Position cat slightly down from the top of the container
        optimalTop = 19;
      }

      // Apply an additional offset for narrow screens to position the cat better
      if (viewportWidth <= 768) {
        const mobileAdjustment = 5;
        optimalTop += mobileAdjustment;
      }

      setContainerTop(optimalTop);

      // Scale cat based on container width with a mobile-specific adjustment
      const baseSize = size;
      const scaleFactor = Math.min(containerWidth / 500, 1);

      // Make the cat slightly smaller on mobile for better proportions
      const mobileScaleFactor = viewportWidth <= 768 ? 0.9 : 1.0;
      setCatSize(baseSize * scaleFactor * mobileScaleFactor);

      // Show/hide based on visibility
      setIsVisible(rect.top < viewportHeight);

      // Get container's z-index for layering
      const containerComputedStyle = window.getComputedStyle(
        containerRef.current,
      );
      const containerZ =
        containerComputedStyle.zIndex === "auto"
          ? 1
          : parseInt(containerComputedStyle.zIndex, 10);
      setContainerZIndex(containerZ);
    }
  }, [containerRef, size]);

  const handleKeyDown = useCallback(
    (e) => {
      if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey) {
        return;
      }

      const now = Date.now();
      if (now - lastKeyTimeRef.current > 1000) {
        lastKeyTimeRef.current = now;
      }

      // Add the key to the set of keys being held down
      keysHeldRef.current.add(e.key);
      setIsPawsDown(true);

      // Only trigger onBongo if it wasn't already paws down
      if (!isPawsDown && onBongo) {
        onBongo();
      }
    },
    [isPawsDown, onBongo],
  );

  const handleKeyUp = useCallback((e) => {
    // Remove the key from the set of keys being held down
    keysHeldRef.current.delete(e.key);

    // If no keys are being held down anymore, set paws up
    if (keysHeldRef.current.size === 0) {
      setIsPawsDown(false);
    }
  }, []);

  // Refs for timeout cleanup
  const scrollTimeoutRef = useRef(null);
  const resizeTimeoutRef = useRef(null);
  const orientationTimeoutRef = useRef(null);
  const mutationTimeoutRef = useRef(null);

  // Set up event listeners and observers with performance optimizations
  useEffect(() => {
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);

    // Set up ResizeObserver for container positioning
    let cleanupContainerListeners = null;

    if (containerRef && containerRef.current) {
      resizeObserverRef.current = new ResizeObserver(updatePosition);
      resizeObserverRef.current.observe(containerRef.current);

      // Initial position calculation with RAF to avoid forced reflow
      requestAnimationFrame(updatePosition);

      // Throttled scroll handler to prevent excessive reflows
      const handleScroll = () => {
        if (scrollTimeoutRef.current) return;
        scrollTimeoutRef.current = requestAnimationFrame(() => {
          updatePosition();
          scrollTimeoutRef.current = null;
        });
      };

      // Throttled resize handler
      const handleResize = () => {
        if (resizeTimeoutRef.current) return;
        resizeTimeoutRef.current = requestAnimationFrame(() => {
          updatePosition();
          resizeTimeoutRef.current = null;
        });
      };

      // Track container position with throttled events
      window.addEventListener("scroll", handleScroll, { passive: true });
      window.addEventListener("resize", handleResize, { passive: true });

      // Debounced orientation change handler
      const handleOrientationChange = () => {
        if (orientationTimeoutRef.current) return;
        orientationTimeoutRef.current = setTimeout(() => {
          requestAnimationFrame(updatePosition);
          orientationTimeoutRef.current = null;
        }, 100);
      };

      window.addEventListener("orientationchange", handleOrientationChange);

      // Throttled MutationObserver to reduce DOM observation overhead
      const handleMutation = () => {
        if (mutationTimeoutRef.current) return;
        mutationTimeoutRef.current = requestAnimationFrame(() => {
          updatePosition();
          mutationTimeoutRef.current = null;
        });
      };

      const mutationObserver = new MutationObserver(handleMutation);
      mutationObserver.observe(document.body, {
        childList: true,
        subtree: false, // Only observe direct children to reduce overhead
        attributes: false, // Disable attribute observation to reduce reflows
      });

      cleanupContainerListeners = () => {
        if (resizeObserverRef.current) {
          resizeObserverRef.current.disconnect();
        }

        window.removeEventListener("scroll", handleScroll);
        window.removeEventListener("resize", handleResize);
        window.removeEventListener(
          "orientationchange",
          handleOrientationChange,
        );
        mutationObserver.disconnect();

        // Clean up timeouts
        if (scrollTimeoutRef.current) {
          cancelAnimationFrame(scrollTimeoutRef.current);
          scrollTimeoutRef.current = null;
        }
        if (resizeTimeoutRef.current) {
          cancelAnimationFrame(resizeTimeoutRef.current);
          resizeTimeoutRef.current = null;
        }
        if (orientationTimeoutRef.current) {
          clearTimeout(orientationTimeoutRef.current);
          orientationTimeoutRef.current = null;
        }
        if (mutationTimeoutRef.current) {
          cancelAnimationFrame(mutationTimeoutRef.current);
          mutationTimeoutRef.current = null;
        }
      };
    }

    return () => {
      // * Always clean up keydown/keyup listeners
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);

      // * Clean up container listeners if they were set up
      if (cleanupContainerListeners) {
        cleanupContainerListeners();
      }
    };
  }, [handleKeyDown, handleKeyUp, containerRef, updatePosition]);

  return {
    isPawsDown,
    containerTop,
    catSize,
    isVisible,
    containerZIndex,
    updatePosition,
  };
}
