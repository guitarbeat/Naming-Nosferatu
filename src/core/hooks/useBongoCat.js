/**
 * @module useBongoCat
 * @description Custom hook for BongoCat component event handling and positioning with enhanced animations
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - export function useBongoCat( (line 45)
 *   - if (containerRef && containerRef.current) (line 58)
 *   - if (viewportWidth <= 768) (line 68)
 *   - setContainerTop(optimalTop); (line 73)
 *   - setCatSize(baseSize * scaleFactor * mobileScaleFactor); (line 81)
 *   - setIsVisible(rect.top < viewportHeight); (line 84)
 *   - setContainerZIndex(containerZ); (line 94)
 *   - if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey) (line 100)
 *   - if (now - lastKeyTimeRef.current > 1000) (line 105)
 *   - setIsPawsDown(true); (line 111)
 *   - if (!isPawsDown && onBongo) (line 114)
 *   - onBongo(); (line 115)
 *   - if (keysHeldRef.current.size === 0) (line 126)
 *   - setIsPawsDown(false); (line 127)
 *   - useEffect(() => (line 132)
 *   - if (containerRef && containerRef.current) (line 137)
 *   - updatePosition(); (line 142)
 *   - const handleScroll = () => (line 145)
 *   - requestAnimationFrame(updatePosition); (line 146)
 *   - return () => (line 165)
 *   - if (resizeObserverRef.current) (line 166)
 *   - return () => (line 178)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

import { useCallback, useEffect, useRef, useState } from "react";
import {
  ANIMATION_STATES,
  TYPING_SPEED_THRESHOLDS,
  MILESTONE_THRESHOLDS,
  DEFAULT_CONFIG,
} from "../../shared/components/BongoCat/constants";

/**
 * Custom hook for BongoCat component functionality with enhanced animations
 * @param {Object} options - Hook options
 * @param {Object} options.containerRef - Reference to the container element
 * @param {number} options.size - Base size of the cat
 * @param {Function} options.onBongo - Callback when cat is bongoed
 * @param {boolean} options.reduceMotion - Whether to reduce motion for accessibility
 * @param {boolean} options.enableSounds - Whether to enable sound effects
 * @returns {Object} Hook state and handlers
 */
export function useBongoCat({
  containerRef,
  size,
  onBongo,
  reduceMotion: reduceMotionProp = DEFAULT_CONFIG.reduceMotion,
  enableSounds = DEFAULT_CONFIG.enableSounds,
}) {
  // * Check system preference for reduced motion
  const systemPrefersReducedMotion =
    typeof window !== "undefined" &&
    window.matchMedia("(prefers-reduced-motion: reduce)").matches;
  const reduceMotion = reduceMotionProp || systemPrefersReducedMotion;
  const [isPawsDown, setIsPawsDown] = useState(false);
  const [containerTop, setContainerTop] = useState(0);
  const [catSize, setCatSize] = useState(size);
  const [isVisible, setIsVisible] = useState(true);
  const [containerZIndex, setContainerZIndex] = useState(0);
  const [animationState, setAnimationState] = useState(ANIMATION_STATES.IDLE);
  const [headTilt, setHeadTilt] = useState(0);
  const [eyePosition, setEyePosition] = useState({ x: 0, y: 0 });
  const [tailAngle, setTailAngle] = useState(0);
  const [earTwitch, setEarTwitch] = useState(false);

  const lastKeyTimeRef = useRef(0);
  const keysHeldRef = useRef(new Set());
  const resizeObserverRef = useRef(null);
  const typingHistoryRef = useRef([]);
  const characterCountRef = useRef(0);
  const lastBackspaceTimeRef = useRef(0);
  const pauseStartTimeRef = useRef(null);
  const cursorPositionRef = useRef({ x: 0, y: 0 });
  const animationFrameRef = useRef(null);

  // Calculate position based on container position with debouncing
  const updatePosition = useCallback(() => {
    if (containerRef && containerRef.current) {
      const rect = containerRef.current.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      const viewportWidth = window.innerWidth;
      const containerWidth = rect.width;

      // Try to find a form element within the container to position relative to it
      const formElement = containerRef.current.querySelector("form");
      let optimalTop = 19; // Default position near top

      if (formElement) {
        // Position cat relative to the form - slightly above it
        const formRect = formElement.getBoundingClientRect();
        const containerRect = containerRef.current.getBoundingClientRect();
        // Calculate position relative to container
        optimalTop = formRect.top - containerRect.top - 60; // 60px above the form
        // Ensure it's not too high (minimum 19px from top)
        optimalTop = Math.max(19, optimalTop);
      } else {
        // Fallback: Position cat slightly down from the top of the container
        optimalTop = 19;
      }

      // Apply an additional offset for narrow screens to position the cat better
      if (viewportWidth <= 768) {
        const mobileAdjustment = 5;
        optimalTop += mobileAdjustment;
      }

      setContainerTop(optimalTop);

      // Scale cat based on container width with a mobile-specific adjustment
      const baseSize = size;
      const scaleFactor = Math.min(containerWidth / 500, 1);

      // Make the cat slightly smaller on mobile for better proportions
      const mobileScaleFactor = viewportWidth <= 768 ? 0.9 : 1.0;
      setCatSize(baseSize * scaleFactor * mobileScaleFactor);

      // Show/hide based on visibility
      setIsVisible(rect.top < viewportHeight);

      // Get container's z-index for layering
      const containerComputedStyle = window.getComputedStyle(
        containerRef.current,
      );
      const containerZ =
        containerComputedStyle.zIndex === "auto"
          ? 1
          : parseInt(containerComputedStyle.zIndex, 10);
      setContainerZIndex(containerZ);
    }
  }, [containerRef, size]);

  /**
   * Calculate typing speed (characters per second)
   * @returns {number} Typing speed in CPS
   */
  const calculateTypingSpeed = useCallback(() => {
    const now = Date.now();
    const recentHistory = typingHistoryRef.current.filter(
      (entry) => now - entry.time < 2000, // Last 2 seconds
    );
    if (recentHistory.length < 2) return 0;
    const timeSpan = (now - recentHistory[0].time) / 1000; // Convert to seconds
    return recentHistory.length / timeSpan;
  }, []);

  /**
   * Check for milestone achievements
   * @param {number} count - Current character count
   */
  const checkMilestones = useCallback(
    (count) => {
      const milestone = MILESTONE_THRESHOLDS.find(
        (threshold) =>
          characterCountRef.current < threshold && count >= threshold,
      );
      if (milestone) {
        setAnimationState(ANIMATION_STATES.CELEBRATING);
        setTimeout(() => {
          setAnimationState(ANIMATION_STATES.IDLE);
        }, 2000);
        if (enableSounds) {
          // * Sound effect would be triggered here if enabled
        }
      }
    },
    [enableSounds],
  );

  /**
   * Update cursor position tracking for eye following
   */
  const updateCursorPosition = useCallback(
    (e) => {
      if (containerRef?.current) {
        const rect = containerRef.current.getBoundingClientRect();
        const catCenterX = rect.left + rect.width / 2;
        const catCenterY = rect.top + rect.height / 2;
        const deltaX = e.clientX - catCenterX;
        const deltaY = e.clientY - catCenterY;
        // Normalize to -1 to 1 range for eye movement
        const maxDistance = Math.max(rect.width, rect.height) / 2;
        cursorPositionRef.current = {
          x: Math.max(-1, Math.min(1, deltaX / maxDistance)),
          y: Math.max(-1, Math.min(1, deltaY / maxDistance)),
        };
      }
    },
    [containerRef],
  );

  /**
   * Animation loop for smooth 60fps animations
   */
  const animationLoop = useCallback(
    function loop() {
      if (reduceMotion) {
        animationFrameRef.current = null;
        return;
      }

      // * Update eye position to follow cursor
      setEyePosition({
        x: cursorPositionRef.current.x * 2, // Max 2px movement
        y: cursorPositionRef.current.y * 2,
      });

      // * Update tail swish based on animation state
      const time = Date.now() / 1000;
      if (animationState === ANIMATION_STATES.TYPING_FAST) {
        setTailAngle(Math.sin(time * 4) * 15); // Fast swish
      } else if (animationState === ANIMATION_STATES.IDLE) {
        setTailAngle(Math.sin(time * 0.8) * 8); // Slow idle swish
      } else if (animationState === ANIMATION_STATES.SLEEPY) {
        setTailAngle(Math.sin(time * 0.3) * 3); // Very slow sleepy swish
      } else {
        setTailAngle(Math.sin(time * 1.5) * 10); // Normal swish
      }

      // * Random ear twitches
      if (Math.random() < 0.01) {
        // 1% chance per frame
        setEarTwitch(true);
        setTimeout(() => setEarTwitch(false), 150);
      }

      animationFrameRef.current = requestAnimationFrame(loop);
    },
    [reduceMotion, animationState],
  );

  const handleKeyDown = useCallback(
    (e) => {
      if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey) {
        return;
      }

      const now = Date.now();
      const isBackspace = e.key === "Backspace" || e.key === "Delete";

      // Track backspace for confused animation
      if (isBackspace) {
        lastBackspaceTimeRef.current = now;
        setAnimationState(ANIMATION_STATES.BACKSPACE);
        setTimeout(() => {
          // Return to previous state after backspace animation
          const speed = calculateTypingSpeed();
          if (speed > TYPING_SPEED_THRESHOLDS.FAST) {
            setAnimationState(ANIMATION_STATES.TYPING_FAST);
          } else if (speed > TYPING_SPEED_THRESHOLDS.SLOW) {
            setAnimationState(ANIMATION_STATES.TYPING_SLOW);
          } else {
            setAnimationState(ANIMATION_STATES.IDLE);
          }
        }, 500);
      } else {
        // Track typing for speed calculation
        typingHistoryRef.current.push({ time: now });
        // Keep only last 50 entries
        if (typingHistoryRef.current.length > 50) {
          typingHistoryRef.current.shift();
        }

        characterCountRef.current += 1;
        checkMilestones(characterCountRef.current);

        // Determine typing speed state
        const speed = calculateTypingSpeed();
        if (speed > TYPING_SPEED_THRESHOLDS.FAST) {
          setAnimationState(ANIMATION_STATES.TYPING_FAST);
          setHeadTilt(Math.sin(now / 200) * 5); // Slight head movement
        } else if (speed > TYPING_SPEED_THRESHOLDS.SLOW) {
          setAnimationState(ANIMATION_STATES.TYPING_SLOW);
          setHeadTilt(0);
        } else {
          setAnimationState(ANIMATION_STATES.IDLE);
        }

        // Clear pause timer
        pauseStartTimeRef.current = null;
      }

      if (now - lastKeyTimeRef.current > 1000) {
        lastKeyTimeRef.current = now;
      }

      // Add the key to the set of keys being held down
      keysHeldRef.current.add(e.key);
      setIsPawsDown(true);

      // Only trigger onBongo if it wasn't already paws down
      if (!isPawsDown && onBongo) {
        onBongo();
      }
    },
    [isPawsDown, onBongo, calculateTypingSpeed, checkMilestones],
  );

  const handleKeyUp = useCallback((e) => {
    // Remove the key from the set of keys being held down
    keysHeldRef.current.delete(e.key);

    // If no keys are being held down anymore, set paws up
    if (keysHeldRef.current.size === 0) {
      setIsPawsDown(false);
      // Start pause timer
      pauseStartTimeRef.current = Date.now();
    }
  }, []);

  // Refs for timeout cleanup
  const scrollTimeoutRef = useRef(null);
  const resizeTimeoutRef = useRef(null);
  const orientationTimeoutRef = useRef(null);
  const mutationTimeoutRef = useRef(null);

  // * Check for long pauses to trigger sleepy state
  useEffect(() => {
    const pauseCheckInterval = setInterval(() => {
      if (
        pauseStartTimeRef.current &&
        Date.now() - pauseStartTimeRef.current > 5000 && // 5 seconds
        animationState !== ANIMATION_STATES.SLEEPY &&
        !isPawsDown
      ) {
        setAnimationState(ANIMATION_STATES.SLEEPY);
      } else if (isPawsDown || Date.now() - pauseStartTimeRef.current < 5000) {
        if (animationState === ANIMATION_STATES.SLEEPY) {
          const speed = calculateTypingSpeed();
          if (speed > TYPING_SPEED_THRESHOLDS.FAST) {
            setAnimationState(ANIMATION_STATES.TYPING_FAST);
          } else if (speed > TYPING_SPEED_THRESHOLDS.SLOW) {
            setAnimationState(ANIMATION_STATES.TYPING_SLOW);
          } else {
            setAnimationState(ANIMATION_STATES.IDLE);
          }
        }
      }
    }, 1000);

    return () => clearInterval(pauseCheckInterval);
  }, [animationState, isPawsDown, calculateTypingSpeed]);

  // * Start animation loop
  useEffect(() => {
    if (!reduceMotion) {
      animationFrameRef.current = requestAnimationFrame(animationLoop);
    }
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [animationLoop, reduceMotion]);

  // * Track cursor movement for eye following
  useEffect(() => {
    if (reduceMotion) return;
    const handleMouseMove = (e) => {
      requestAnimationFrame(() => updateCursorPosition(e));
    };
    document.addEventListener("mousemove", handleMouseMove, { passive: true });
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
    };
  }, [updateCursorPosition, reduceMotion]);

  // Set up event listeners and observers with performance optimizations
  useEffect(() => {
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);

    // Set up ResizeObserver for container positioning
    let cleanupContainerListeners = null;

    if (containerRef && containerRef.current) {
      resizeObserverRef.current = new ResizeObserver(updatePosition);
      resizeObserverRef.current.observe(containerRef.current);

      // Initial position calculation with RAF to avoid forced reflow
      requestAnimationFrame(updatePosition);

      // Throttled scroll handler to prevent excessive reflows
      const handleScroll = () => {
        if (scrollTimeoutRef.current) return;
        scrollTimeoutRef.current = requestAnimationFrame(() => {
          updatePosition();
          scrollTimeoutRef.current = null;
        });
      };

      // Throttled resize handler
      const handleResize = () => {
        if (resizeTimeoutRef.current) return;
        resizeTimeoutRef.current = requestAnimationFrame(() => {
          updatePosition();
          resizeTimeoutRef.current = null;
        });
      };

      // Track container position with throttled events
      window.addEventListener("scroll", handleScroll, { passive: true });
      window.addEventListener("resize", handleResize, { passive: true });

      // Debounced orientation change handler
      const handleOrientationChange = () => {
        if (orientationTimeoutRef.current) return;
        orientationTimeoutRef.current = setTimeout(() => {
          requestAnimationFrame(updatePosition);
          orientationTimeoutRef.current = null;
        }, 100);
      };

      window.addEventListener("orientationchange", handleOrientationChange);

      // Throttled MutationObserver to reduce DOM observation overhead
      const handleMutation = () => {
        if (mutationTimeoutRef.current) return;
        mutationTimeoutRef.current = requestAnimationFrame(() => {
          updatePosition();
          mutationTimeoutRef.current = null;
        });
      };

      const mutationObserver = new MutationObserver(handleMutation);
      mutationObserver.observe(document.body, {
        childList: true,
        subtree: false, // Only observe direct children to reduce overhead
        attributes: false, // Disable attribute observation to reduce reflows
      });

      cleanupContainerListeners = () => {
        if (resizeObserverRef.current) {
          resizeObserverRef.current.disconnect();
        }

        window.removeEventListener("scroll", handleScroll);
        window.removeEventListener("resize", handleResize);
        window.removeEventListener(
          "orientationchange",
          handleOrientationChange,
        );
        mutationObserver.disconnect();

        // Clean up timeouts
        if (scrollTimeoutRef.current) {
          cancelAnimationFrame(scrollTimeoutRef.current);
          scrollTimeoutRef.current = null;
        }
        if (resizeTimeoutRef.current) {
          cancelAnimationFrame(resizeTimeoutRef.current);
          resizeTimeoutRef.current = null;
        }
        if (orientationTimeoutRef.current) {
          clearTimeout(orientationTimeoutRef.current);
          orientationTimeoutRef.current = null;
        }
        if (mutationTimeoutRef.current) {
          cancelAnimationFrame(mutationTimeoutRef.current);
          mutationTimeoutRef.current = null;
        }
      };
    }

    return () => {
      // * Always clean up keydown/keyup listeners
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);

      // * Clean up container listeners if they were set up
      if (cleanupContainerListeners) {
        cleanupContainerListeners();
      }
    };
  }, [handleKeyDown, handleKeyUp, containerRef, updatePosition]);

  return {
    isPawsDown,
    containerTop,
    catSize,
    isVisible,
    containerZIndex,
    updatePosition,
    animationState,
    headTilt,
    eyePosition,
    tailAngle,
    earTwitch,
    characterCount: characterCountRef.current,
  };
}
