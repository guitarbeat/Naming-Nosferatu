/**
 * @module Results
 * @description Main results component that displays the final rankings of cat names.
 * Shows the tournament results with ratings and provides option to restart.
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - if (!voteHistory || !voteHistory.length) (line 82)
 *   - useEffect(() => (line 129)
 *   - setCurrentRankings(processedRankings); (line 132)
 *   - setIsLoading(false); (line 141)
 *   - async (adjustedRankings) => (line 146)
 *   - setIsLoading(true); (line 148)
 *   - setCurrentRankings(updatedRankings); (line 171)
 *   - setIsLoading(false); (line 186)
 *   - setToast((prev) => ( (line 193)
 *   - useEffect(() => (line 196)
 *   - if (toast.show) (line 197)
 *   - return () => clearTimeout(timer); (line 199)
 *   - useEffect(() => (line 203)
 *   - if (header && window.vfx) (line 206)
 *   - if (window.vfx) (line 213)
 *   - if (bracket && window.vfx) (line 220)
 *   - return () => (line 224)
 *   - if (window.vfx) (line 225)
 *   - if (header) (line 226)
 *   - if (bracket) (line 230)
 *   - useEffect(() => (line 238)
 *   - const addVfx = (selector, config) => (line 241)
 *   - if (el && window.vfx) (line 243)
 *   - addVfx(".stat-card", (line 254)
 *   - addVfx(".tournament-bracket", (line 255)
 *   - return () => (line 257)
 *   - if (isLoading) (line 262)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

import React, { useState, useEffect, useCallback, useMemo } from "react";

import PropTypes from "prop-types";

import RankingAdjustment from "./RankingAdjustment";
import Bracket from "../../shared/components/Bracket/Bracket";
import CalendarButton from "../../shared/components/CalendarButton/CalendarButton";
import StartTournamentButton from "../../shared/components/StartTournamentButton/StartTournamentButton";
import StatsCard from "../../shared/components/StatsCard/StatsCard";
import { Card, Toast } from "@components";
import { useToast } from "./hooks/useToast";
import { calculateBracketRound } from "../../shared/utils/tournamentUtils";
import styles from "./Results.module.css";

function Results({
  ratings,
  onStartNew,
  userName,
  onUpdateRatings,
  currentTournamentNames,
  voteHistory,
}) {
  const [currentRankings, setCurrentRankings] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  // * Memoize hiddenNames Set to prevent recreation on every render
  const hiddenNames = useMemo(() => new Set(), []);

  const { toasts, showToast, removeToast } = useToast({
    maxToasts: 1,
    defaultDuration: 3000,
  });

  const showToastMessage = useCallback(
    (message, type = "info") => {
      showToast({
        message,
        type,
      });
    },
    [showToast],
  );

  // * Memoize tournament name set to prevent recreation on every render
  const tournamentNameSet = useMemo(
    () => new Set(currentTournamentNames?.map((n) => n.name) || []),
    [currentTournamentNames],
  );

  // * Memoize bracket matches calculation to prevent recalculation on every render
  const bracketMatches = useMemo(() => {
    if (!voteHistory || !voteHistory.length) {
      return [];
    }

    const namesCount = currentTournamentNames?.length || 0;
    return voteHistory
      .filter(
        (vote) =>
          vote?.match?.left?.name &&
          vote?.match?.right?.name &&
          tournamentNameSet.has(vote.match.left.name) &&
          tournamentNameSet.has(vote.match.right.name),
      )
      .map((vote, index) => {
        // Prefer outcome fields if present
        const leftOutcome = vote?.match?.left?.outcome;
        const rightOutcome = vote?.match?.right?.outcome;
        let winner;
        if (leftOutcome || rightOutcome) {
          const leftWin = leftOutcome === "win";
          const rightWin = rightOutcome === "win";
          if (leftWin && rightWin)
            winner = 0; // both
          else if (leftWin && !rightWin) winner = -1;
          else if (!leftWin && rightWin) winner = 1;
          else winner = 2; // neither/skip
        } else if (typeof vote.result === "number") {
          // Handle exact values (-1, 1, 0.5, 0) and fallback thresholds
          if (vote.result === -1) winner = -1;
          else if (vote.result === 1) winner = 1;
          else if (vote.result === 0.5) winner = 0;
          else if (vote.result === 0) winner = 2;
          else if (vote.result < -0.1) winner = -1;
          else if (vote.result > 0.1) winner = 1;
          else if (Math.abs(vote.result) <= 0.1) winner = 0;
          else winner = 2;
        } else {
          winner = 2;
        }

        const matchNumber = vote?.matchNumber ?? index + 1;
        
        // * Use the helper function for round calculation
        const calculatedRound = calculateBracketRound(namesCount, matchNumber);

        return {
          id: matchNumber,
          round: calculatedRound,
          name1: vote?.match?.left?.name || "Unknown",
          name2: vote?.match?.right?.name || "Unknown",
          winner,
        };
      });
  }, [voteHistory, tournamentNameSet, currentTournamentNames]);

  // Memoized rankings processor
  const processRankings = useCallback(
    (ratingsData) => {
      // Filter to only include names from the current tournament
      const tournamentNameSet = new Set(
        currentTournamentNames?.map((n) => n.name) || [],
      );
      const nameToIdMap = new Map(
        (currentTournamentNames || [])
          .filter((name) => name?.name)
          .map(({ id, name }) => [name, id]),
      );

      return Object.entries(ratingsData || {})
        .filter(([name]) => tournamentNameSet.has(name))
        .map(([name, rating]) => ({
          id: nameToIdMap.get(name),
          name,
          rating: Math.round(
            typeof rating === "number" ? rating : rating?.rating || 1500,
          ),
          wins: typeof rating === "object" ? rating.wins || 0 : 0,
          losses: typeof rating === "object" ? rating.losses || 0 : 0,
          change: 0,
        }))
        .sort((a, b) => b.rating - a.rating);
    },
    [currentTournamentNames],
  );

  // * Memoize processed rankings to avoid unnecessary recalculations
  const processedRankings = useMemo(
    () => {
      try {
        return processRankings(ratings);
      } catch (error) {
        console.error("Error processing rankings:", error);
        return [];
      }
    },
    [ratings, processRankings],
  );

  useEffect(() => {
    try {
      setCurrentRankings(processedRankings);
    } catch (error) {
      console.error("Error setting rankings:", error);
      showToastMessage("Error processing rankings data", "error");
    } finally {
      setIsLoading(false);
    }
  }, [processedRankings, showToastMessage]);

  const handleSaveAdjustments = useCallback(
    async (adjustedRankings) => {
      try {
        setIsLoading(true);

        const updatedRankings = adjustedRankings.map((ranking) => {
          const oldRanking = currentRankings.find(
            (r) => r.name === ranking.name,
          );
          return {
            ...ranking,
            change: oldRanking ? ranking.rating - oldRanking.rating : 0,
          };
        });

        const newRatings = updatedRankings.map(({ name, rating }) => {
          const existingRating = ratings[name];
          return {
            name,
            rating: Math.round(rating),
            wins: existingRating?.wins || 0,
            losses: existingRating?.losses || 0,
          };
        });

        await onUpdateRatings(newRatings);
        setCurrentRankings(updatedRankings);

        showToastMessage("Rankings updated successfully!", "success");
      } catch (error) {
        console.error("Failed to update rankings:", error);
        showToastMessage(
          "Failed to update rankings. Please try again.",
          "error",
        );
      } finally {
        setIsLoading(false);
      }
    },
    [currentRankings, ratings, onUpdateRatings, showToastMessage],
  );

  // * Single optimized vfx effect hook (removed duplicate)
  useEffect(() => {
    if (!window.vfx) return;

    const vfxElements = [];

    const addVfx = (selector, config) => {
      const el = document.querySelector(selector);
      if (el) {
        window.vfx.add(el, config);
        vfxElements.push(el);
      }
    };

    addVfx(".results-header", {
      shader: "wave",
      frequency: 2,
      amplitude: 0.01,
    });
    addVfx(".stat-card", { shader: "glitch", intensity: 0.2 });
    addVfx(".tournament-bracket", { shader: "rgbShift", intensity: 0.3 });

    return () => {
      vfxElements.forEach((el) => window.vfx?.remove(el));
    };
  }, []);

  if (isLoading) {
    return (
      <div
        className={styles.loading}
        role="status"
        aria-label="Loading rankings"
      >
        <div className={styles.loadingSpinner} aria-hidden="true" />
        <p>Processing rankings...</p>
      </div>
    );
  }

  return (
    <div className={styles.container}>
      <Card
        as="header"
        className={styles.header}
        background="glass"
        padding="large"
        shadow="medium"
      >
        <h2 className={styles.title}>Tournament Results</h2>
        <p className={styles.welcome}>
          Welcome back, <span className={styles.userName}>{userName}</span>!
          Here are your latest name rankings.
        </p>
      </Card>

      <div className={styles.content}>
        <div className={styles.statsGrid}>
          <StatsCard
            title="Total Names"
            value={currentRankings.length}
            emoji="ðŸ“Š"
            variant="primary"
            className={styles.statCard}
            valueClassName={styles.statValue}
          />
        </div>

        <RankingAdjustment
          rankings={currentRankings}
          onSave={handleSaveAdjustments}
          onCancel={onStartNew}
        />

        <div className={styles.actions}>
          <div className={styles.actionsButtons}>
            <StartTournamentButton
              onClick={onStartNew}
              className={styles.startNewButton}
              ariaLabel="Start new tournament"
            >
              Start New Tournament
            </StartTournamentButton>
            <CalendarButton
              rankings={currentRankings}
              userName={userName}
              hiddenNames={hiddenNames}
            />
          </div>
          <p className={styles.tip} role="note">
            Starting a new tournament will let you rate more names while keeping
            your current rankings.
          </p>
        </div>

        {bracketMatches.length > 0 && (
          <div className={styles.tournamentBracket}>
            <h3>Tournament Bracket</h3>
            <Bracket matches={bracketMatches} />
          </div>
        )}
      </div>

      <Toast
        variant="container"
        toasts={toasts}
        removeToast={removeToast}
        position="bottom-right"
        maxToasts={1}
      />
    </div>
  );
}

Results.displayName = "Results";

Results.propTypes = {
  ratings: PropTypes.object.isRequired,
  onStartNew: PropTypes.func.isRequired,
  userName: PropTypes.string.isRequired,
  onUpdateRatings: PropTypes.func.isRequired,
  currentTournamentNames: PropTypes.array,
  voteHistory: PropTypes.array,
};

// * Memoize Results component to prevent unnecessary re-renders when parent re-renders
export default React.memo(Results);
