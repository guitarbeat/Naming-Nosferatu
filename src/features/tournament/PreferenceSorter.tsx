/**
 * @module PreferenceSorter
 * @description A class that implements a merge sort algorithm with custom comparisons
 * for sorting cat names based on user preferences.
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - PreferenceSorter (line 36):
 *     - constructor(items) (line 37)
 *     - if (!Array.isArray(items)) (line 38)
 *     - getName(item) (line 51)
 *     - addPreference(item1, item2, value) (line 55)
 *   - getPreference(item1, item2) (line 60)
 *   - if (this.preferences.has(key)) (line 70)
 *   - getCurrentRankings() (line 82)
 *   - if (this.ranks.length > 0) (line 83)
 *   - async sort(compareCallback) (line 89)
 *   - if (!this.rec || this.rec.length !== n) (line 92)
 *   - async sortRecursive(left, right, compareCallback) (line 100)
 *   - if (right - left < 1) (line 101)
 *   - if (left === right) (line 102)
 *   - async mergeSubGroups(left, mid, right, compareCallback) (line 114)
 *   - while (i <= mid && j <= right) (line 119)
 *   - if (result <= -0.5) (line 123)
 *   - while (i <= mid) (line 140)
 *   - while (j <= right) (line 143)
 *   - for (let k = 0; k < merged.length; k++) (line 147)
 *   - if (left === 0 && right === this.items.length - 1) (line 152)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

export class PreferenceSorter {
  items: string[];
  preferences: Map<string, number>;
  currentRankings: string[];
  ranks: string[];
  rec: number[];
  // Lazy iteration state
  private _i: number;
  private _j: number;

  history: Array<{ a: string; b: string; value: number }>;

  // Expose currentIndex for compatibility, though it is virtual
  get currentIndex(): number {
    if (this._i >= this.items.length - 1) return (this.items.length * (this.items.length - 1)) / 2;

    const n = this.items.length;
    const previousRowsPairs = this._i * (n - 1) - (this._i * (this._i - 1)) / 2;
    const currentRowsPairs = this._j - this._i - 1;
    return previousRowsPairs + currentRowsPairs;
  }

  set currentIndex(val: number) {
    if (val === 0) {
      this._i = 0;
      this._j = 1;
      return;
    }
    if (process.env.NODE_ENV === "development") {
      console.warn("Setting currentIndex manually on PreferenceSorter is not fully supported in lazy mode except for 0.");
    }
  }

  constructor(items: string[]) {
    if (!Array.isArray(items)) {
      throw new Error("PreferenceSorter requires an array of items");
    }
    this.items = items;
    this.preferences = new Map<string, number>();
    this.currentRankings = [...items];
    this.ranks = [];
    this.rec = new Array(items.length).fill(0);

    // Initialize lazy iteration state
    this._i = 0;
    this._j = 1;

    this.history = [];
  }

  getName(item: string | { name?: string } | null | undefined): string {
    if (item == null) {
      return "";
    }
    return typeof item === "string" ? item : item.name || "";
  }

  addPreference(item1: string | { name?: string }, item2: string | { name?: string }, value: number): void {
    const key = `${this.getName(item1)}-${this.getName(item2)}`;
    this.preferences.set(key, value);
    // Record history for undo support
    this.history.push({
      a: this.getName(item1),
      b: this.getName(item2),
      value,
    });
  }

  getPreference(item1: string | { name?: string }, item2: string | { name?: string }): number {
    const key = `${this.getName(item1)}-${this.getName(item2)}`;
    const reverseKey = `${this.getName(item2)}-${this.getName(item1)}`;

    if (this.preferences.has(key)) {
      return this.preferences.get(key) ?? 0;
    } else if (this.preferences.has(reverseKey)) {
      const reverseValue = this.preferences.get(reverseKey);
      return reverseValue !== undefined ? -reverseValue : 0;
    } else {
      return 0;
    }
  }

  getCurrentRankings(): string[] {
    if (this.ranks.length > 0) {
      return this.ranks;
    }
    return this.currentRankings;
  }

  async sort(compareCallback: (a: string, b: string) => Promise<number> | number): Promise<void> {
    const n = this.items.length;

    if (!this.rec || this.rec.length !== n) {
      this.rec = new Array(n).fill(0);
    }

    await this.sortRecursive(0, n - 1, compareCallback);
  }

  async sortRecursive(left: number, right: number, compareCallback: (a: string, b: string) => Promise<number> | number): Promise<void> {
    if (right - left < 1) {
      if (left === right && left >= 0 && left < this.items.length) {
        this.ranks.push(this.items[left]);
      }
      return;
    }

    const mid = Math.floor((left + right) / 2);
    await this.sortRecursive(left, mid, compareCallback);
    await this.sortRecursive(mid + 1, right, compareCallback);
    await this.mergeSubGroups(left, mid, right, compareCallback);
  }

  async mergeSubGroups(left: number, mid: number, right: number, compareCallback: (a: string, b: string) => Promise<number> | number): Promise<void> {
    // Validate bounds
    if (
      left < 0 ||
      right >= this.items.length ||
      left > right ||
      mid < left ||
      mid > right
    ) {
      console.error("Invalid merge bounds:", {
        left,
        mid,
        right,
        itemsLength: this.items.length,
      });
      return;
    }

    let i = left;
    let j = mid + 1;
    const merged: string[] = [];

    while (i <= mid && j <= right) {
      try {
        // Bounds check before accessing
        if (i >= this.items.length || j >= this.items.length) {
          console.error("Array index out of bounds during merge:", {
            i,
            j,
            itemsLength: this.items.length,
          });
          break;
        }
        const result = await compareCallback(this.items[i], this.items[j]);

        if (result <= -0.5) {
          merged.push(this.items[i++]);
        } else if (result >= 0.5) {
          merged.push(this.items[j++]);
        } else if (result < 0) {
          merged.push(this.items[i++]);
          merged.push(this.items[j++]);
        } else {
          merged.push(this.items[j++]);
          merged.push(this.items[i++]);
        }
      } catch (error) {
        console.error("Comparison failed:", error);
        // Handle cancellation or fallback strategy
      }
    }

    while (i <= mid) {
      merged.push(this.items[i++]);
    }
    while (j <= right) {
      merged.push(this.items[j++]);
    }

    for (let k = 0; k < merged.length; k++) {
      this.items[left + k] = merged[k];
      this.currentRankings[left + k] = merged[k];
    }

    if (left === 0 && right === this.items.length - 1) {
      this.ranks = [...merged];
    }
  }

  // Return the next un-judged pair as a match { left, right }
  getNextMatch(): { left: string; right: string } | null {
    const n = this.items.length;

    // We use a temporary cursor to scan forward from current _i, _j
    // But we want to persist the progress so we don't re-scan from 0,0 every time.
    // So _i, _j should point to the *first potentially unjudged* pair.

    while (this._i < n - 1) {
      const a = this.getName(this.items[this._i]);
      const b = this.getName(this.items[this._j]);

      const key = `${a}-${b}`;
      const reverseKey = `${b}-${a}`;

      const hasPref = this.preferences.has(key) || this.preferences.has(reverseKey);

      if (!hasPref) {
        // Found an unjudged pair. Return it.
        // Do NOT advance _i, _j yet. We want to return this pair until it is judged.
        return { left: a, right: b };
      }

      // If judged, advance to check next pair
      this._j++;
      if (this._j >= n) {
        this._i++;
        this._j = this._i + 1;
      }
    }

    return null;
  }

  // Undo last added preference
  undoLastPreference(): boolean {
    const last = this.history.pop();
    if (!last) return false;
    const key = `${last.a}-${last.b}`;
    const reverseKey = `${last.b}-${last.a}`;
    this.preferences.delete(key);
    this.preferences.delete(reverseKey);

    // Step back indices to ensure we revisit this pair
    const indexA = this.items.findIndex(item => this.getName(item) === last.a);
    const indexB = this.items.findIndex(item => this.getName(item) === last.b);

    if (indexA !== -1 && indexB !== -1) {
      // Ensure i < j convention
      if (indexA < indexB) {
        this._i = indexA;
        this._j = indexB;
      } else {
        this._i = indexB;
        this._j = indexA;
      }
    } else {
       // Fallback
       if (this._j > this._i + 1) {
         this._j--;
       } else if (this._i > 0) {
         this._i--;
         this._j = this.items.length - 1;
       }
    }

    return true;
  }
}
