/**
 * @module EloRating
 * @description A class that implements the Elo rating system for ranking cat names.
 * Used to calculate and update ratings based on head-to-head comparisons.
 */

import { ELO_RATING } from "../../core/constants";
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - EloRating (line 23):
 *     - constructor(defaultRating = 1500, kFactor = 40) (line 24)
 *     - getExpectedScore(ratingA, ratingB) (line 31)
 *     - getKFactor(rating, games = 0) (line 35)
 *     - if (games < 15) (line 36)
 *     - if (rating < 1400 || rating > 2000) (line 39)
 *     - updateRating(rating, expected, actual, games = 0) (line 45)
 *   - calculateNewRatings(ratingA, ratingB, outcome, stats = (line 61)
 *   - switch (outcome) (line 71)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

interface EloStats {
  winsA?: number;
  lossesA?: number;
  winsB?: number;
  lossesB?: number;
}

class EloRating {
  defaultRating: number;
  kFactor: number;
  minRating: number;
  maxRating: number;

  constructor(
    defaultRating: number = ELO_RATING.DEFAULT_RATING,
    kFactor: number = ELO_RATING.DEFAULT_K_FACTOR,
  ) {
    this.defaultRating = defaultRating;
    this.kFactor = kFactor;
    this.minRating = ELO_RATING.MIN_RATING;
    this.maxRating = ELO_RATING.MAX_RATING;
  }

  getExpectedScore(ratingA: number, ratingB: number): number {
    return (
      1 / (1 + Math.pow(10, (ratingB - ratingA) / ELO_RATING.RATING_DIVISOR))
    );
  }

  getKFactor(rating: number, games: number = 0): number {
    if (games < ELO_RATING.NEW_PLAYER_GAME_THRESHOLD) {
      return this.kFactor * ELO_RATING.NEW_PLAYER_K_MULTIPLIER;
    }
    if (
      rating < ELO_RATING.LOW_RATING_THRESHOLD ||
      rating > ELO_RATING.HIGH_RATING_THRESHOLD
    ) {
      return this.kFactor * ELO_RATING.EXTREME_RATING_K_MULTIPLIER;
    }
    return this.kFactor;
  }

  updateRating(rating: number, expected: number, actual: number, games: number = 0): number {
    const k = this.getKFactor(rating, games);
    const newRating = Math.round(rating + k * (actual - expected));
    return Math.max(this.minRating, Math.min(this.maxRating, newRating));
  }

  /**
   * Calculate new ratings after a match
   * @param {number} ratingA - Current rating of first item
   * @param {number} ratingB - Current rating of second item
   * @param {'left'|'right'|'both'|'none'} outcome - Match result
   * @param {Object} stats - Player statistics
   * @param {number} [stats.winsA] - Wins for player A
   * @param {number} [stats.lossesA] - Losses for player A
   * @returns {Object} New ratings and updated win/loss counts for both items
   */
  calculateNewRatings(ratingA: number, ratingB: number, outcome: "left" | "right" | "both" | "none" | string, stats: EloStats = {}) {
    const expectedA = this.getExpectedScore(ratingA, ratingB);
    const expectedB = this.getExpectedScore(ratingB, ratingA);

    let actualA, actualB;
    let winsA = stats.winsA || 0;
    let lossesA = stats.lossesA || 0;
    let winsB = stats.winsB || 0;
    let lossesB = stats.lossesB || 0;

    switch (outcome) {
      case "left":
        actualA = ELO_RATING.WIN_SCORE;
        actualB = ELO_RATING.LOSS_SCORE;
        winsA++;
        lossesB++;
        break;
      case "right":
        actualA = ELO_RATING.LOSS_SCORE;
        actualB = ELO_RATING.WIN_SCORE;
        lossesA++;
        winsB++;
        break;
      case "both": // Both names get an equal significant boost
        actualA = ELO_RATING.BOTH_WIN_SCORE;
        actualB = ELO_RATING.BOTH_WIN_SCORE;
        winsA++;
        winsB++;
        break;
      case "none": // Both names get an equal smaller boost
        actualA = ELO_RATING.NEITHER_WIN_SCORE;
        actualB = ELO_RATING.NEITHER_WIN_SCORE;
        break;
      default:
        actualA = ELO_RATING.TIE_SCORE;
        actualB = ELO_RATING.TIE_SCORE;
    }

    const gamesA = winsA + lossesA;
    const gamesB = winsB + lossesB;

    return {
      newRatingA: this.updateRating(ratingA, expectedA, actualA, gamesA),
      newRatingB: this.updateRating(ratingB, expectedB, actualB, gamesB),
      winsA,
      lossesA,
      winsB,
      lossesB,
    };
  }
}

export default EloRating;
