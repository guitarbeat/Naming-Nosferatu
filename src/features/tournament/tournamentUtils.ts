/**
 * @module EloRating
 * @description A class that implements the Elo rating system for ranking cat names.
 * Used to calculate and update ratings based on head-to-head comparisons.
 */

import { ELO_RATING } from "../../core/constants";

/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - EloRating (line 23):
 *     - constructor(defaultRating = 1500, kFactor = 40) (line 24)
 *     - getExpectedScore(ratingA, ratingB) (line 31)
 *     - getKFactor(rating, games = 0) (line 35)
 *     - if (games < 15) (line 36)
 *     - if (rating < 1400 || rating > 2000) (line 39)
 *     - updateRating(rating, expected, actual, games = 0) (line 45)
 *   - calculateNewRatings(ratingA, ratingB, outcome, stats = (line 61)
 *   - switch (outcome) (line 71)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

interface EloStats {
	winsA?: number;
	lossesA?: number;
	winsB?: number;
	lossesB?: number;
}

export class EloRating {
	defaultRating: number;
	kFactor: number;
	minRating: number;
	maxRating: number;

	constructor(
		defaultRating: number = ELO_RATING.DEFAULT_RATING,
		kFactor: number = ELO_RATING.DEFAULT_K_FACTOR,
	) {
		this.defaultRating = defaultRating;
		this.kFactor = kFactor;
		this.minRating = ELO_RATING.MIN_RATING;
		this.maxRating = ELO_RATING.MAX_RATING;
	}

	getExpectedScore(ratingA: number, ratingB: number): number {
		return 1 / (1 + 10 ** ((ratingB - ratingA) / ELO_RATING.RATING_DIVISOR));
	}

	getKFactor(rating: number, games: number = 0): number {
		if (games < ELO_RATING.NEW_PLAYER_GAME_THRESHOLD) {
			return this.kFactor * ELO_RATING.NEW_PLAYER_K_MULTIPLIER;
		}
		if (rating < ELO_RATING.LOW_RATING_THRESHOLD || rating > ELO_RATING.HIGH_RATING_THRESHOLD) {
			return this.kFactor * ELO_RATING.EXTREME_RATING_K_MULTIPLIER;
		}
		return this.kFactor;
	}

	updateRating(rating: number, expected: number, actual: number, games: number = 0): number {
		const k = this.getKFactor(rating, games);
		const newRating = Math.round(rating + k * (actual - expected));
		return Math.max(this.minRating, Math.min(this.maxRating, newRating));
	}

	/**
	 * Calculate new ratings after a match
	 * @param {number} ratingA - Current rating of first item
	 * @param {number} ratingB - Current rating of second item
	 * @param {'left'|'right'|'both'|'none'} outcome - Match result
	 * @param {Object} stats - Player statistics
	 * @param {number} [stats.winsA] - Wins for player A
	 * @param {number} [stats.lossesA] - Losses for player A
	 * @returns {Object} New ratings and updated win/loss counts for both items
	 */
	calculateNewRatings(
		ratingA: number,
		ratingB: number,
		outcome: "left" | "right" | "both" | "none" | string,
		stats: EloStats = {},
	) {
		const expectedA = this.getExpectedScore(ratingA, ratingB);
		const expectedB = this.getExpectedScore(ratingB, ratingA);

		let actualA, actualB;
		let winsA = stats.winsA || 0;
		let lossesA = stats.lossesA || 0;
		let winsB = stats.winsB || 0;
		let lossesB = stats.lossesB || 0;

		switch (outcome) {
			case "left":
				actualA = ELO_RATING.WIN_SCORE;
				actualB = ELO_RATING.LOSS_SCORE;
				winsA++;
				lossesB++;
				break;
			case "right":
				actualA = ELO_RATING.LOSS_SCORE;
				actualB = ELO_RATING.WIN_SCORE;
				lossesA++;
				winsB++;
				break;
			case "both": // Both names get an equal significant boost
				actualA = ELO_RATING.BOTH_WIN_SCORE;
				actualB = ELO_RATING.BOTH_WIN_SCORE;
				winsA++;
				winsB++;
				break;
			case "none": // Both names get an equal smaller boost
				actualA = ELO_RATING.NEITHER_WIN_SCORE;
				actualB = ELO_RATING.NEITHER_WIN_SCORE;
				break;
			default:
				actualA = ELO_RATING.TIE_SCORE;
				actualB = ELO_RATING.TIE_SCORE;
		}

		const gamesA = winsA + lossesA;
		const gamesB = winsB + lossesB;

		return {
			newRatingA: this.updateRating(ratingA, expectedA, actualA, gamesA),
			newRatingB: this.updateRating(ratingB, expectedB, actualB, gamesB),
			winsA,
			lossesA,
			winsB,
			lossesB,
		};
	}
}

/**
 * @module PreferenceSorter
 * @description A class that implements a merge sort algorithm with custom comparisons
 * for sorting cat names based on user preferences.
 */
/**
 * --- AUTO-GENERATED DOCSTRING ---
 * Table of content is automatically generated by Agent Docstrings v1.3.5
 *
 * Classes/Functions:
 *   - PreferenceSorter (line 36):
 *     - constructor(items) (line 37)
 *     - if (!Array.isArray(items)) (line 38)
 *     - getName(item) (line 51)
 *     - addPreference(item1, item2, value) (line 55)
 *   - getPreference(item1, item2) (line 60)
 *   - if (this.preferences.has(key)) (line 70)
 *   - getCurrentRankings() (line 82)
 *   - if (this.ranks.length > 0) (line 83)
 *   - async sort(compareCallback) (line 89)
 *   - if (!this.rec || this.rec.length !== n) (line 92)
 *   - async sortRecursive(left, right, compareCallback) (line 100)
 *   - if (right - left < 1) (line 101)
 *   - if (left === right) (line 102)
 *   - async mergeSubGroups(left, mid, right, compareCallback) (line 114)
 *   - while (i <= mid && j <= right) (line 119)
 *   - if (result <= -0.5) (line 123)
 *   - while (i <= mid) (line 140)
 *   - while (j <= right) (line 143)
 *   - for (let k = 0; k < merged.length; k++) (line 147)
 *   - if (left === 0 && right === this.items.length - 1) (line 152)
 * --- END AUTO-GENERATED DOCSTRING ---
 */

export class PreferenceSorter {
	items: string[];
	preferences: Map<string, number>;
	currentRankings: string[];
	ranks: string[];
	rec: number[];
	// Optimized: pairs are generated on demand to avoid O(N^2) memory allocation
	// pairs: Array<[string, string]>;
	totalPairs: number;
	currentIndex: number;
	history: Array<{ a: string; b: string; value: number }>;

	constructor(items: string[]) {
		if (!Array.isArray(items)) {
			throw new Error("PreferenceSorter requires an array of items");
		}
		this.items = items;
		this.preferences = new Map<string, number>();
		this.currentRankings = [...items];
		this.ranks = [];
		this.rec = Array(Number(items.length)).fill(0);

		// Calculate total pairs: N * (N - 1) / 2
		const N = items.length;
		this.totalPairs = (N * (N - 1)) / 2;

		this.currentIndex = 0;
		this.history = [];
	}

	getName(item: string | { name?: string } | null | undefined): string {
		if (item == null) {
			return "";
		}
		return typeof item === "string" ? item : item.name || "";
	}

	addPreference(
		item1: string | { name?: string },
		item2: string | { name?: string },
		value: number,
	): void {
		const key = `${this.getName(item1)}-${this.getName(item2)}`;
		this.preferences.set(key, value);
		// Record history for undo support
		this.history.push({
			a: this.getName(item1),
			b: this.getName(item2),
			value,
		});
	}

	getPreference(item1: string | { name?: string }, item2: string | { name?: string }): number {
		const key = `${this.getName(item1)}-${this.getName(item2)}`;
		const reverseKey = `${this.getName(item2)}-${this.getName(item1)}`;

		if (this.preferences.has(key)) {
			return this.preferences.get(key) ?? 0;
		} else if (this.preferences.has(reverseKey)) {
			const reverseValue = this.preferences.get(reverseKey);
			return reverseValue !== undefined ? -reverseValue : 0;
		} else {
			return 0;
		}
	}

	getCurrentRankings(): string[] {
		if (this.ranks.length > 0) {
			return this.ranks;
		}
		return this.currentRankings;
	}

	async sort(compareCallback: (a: string, b: string) => Promise<number> | number): Promise<void> {
		const n = this.items.length;

		if (!this.rec || this.rec.length !== n) {
			this.rec = Array(Number(n)).fill(0);
		}

		await this.sortRecursive(0, n - 1, compareCallback);
	}

	async sortRecursive(
		left: number,
		right: number,
		compareCallback: (a: string, b: string) => Promise<number> | number,
	): Promise<void> {
		if (right - left < 1) {
			if (left === right && left >= 0 && left < this.items.length) {
				// biome-ignore lint/style/noNonNullAssertion: Array bounds already checked above
				this.ranks.push(this.items[left]!);
			}
			return;
		}

		const mid = Math.floor((left + right) / 2);
		await this.sortRecursive(left, mid, compareCallback);
		await this.sortRecursive(mid + 1, right, compareCallback);
		await this.mergeSubGroups(left, mid, right, compareCallback);
	}

	async mergeSubGroups(
		left: number,
		mid: number,
		right: number,
		compareCallback: (a: string, b: string) => Promise<number> | number,
	): Promise<void> {
		// Validate bounds
		if (left < 0 || right >= this.items.length || left > right || mid < left || mid > right) {
			console.error("Invalid merge bounds:", {
				left,
				mid,
				right,
				itemsLength: this.items.length,
			});
			return;
		}

		let i = left;
		let j = mid + 1;
		const merged: string[] = [];

		while (i <= mid && j <= right) {
			try {
				// Bounds check before accessing
				if (i >= this.items.length || j >= this.items.length) {
					console.error("Array index out of bounds during merge:", {
						i,
						j,
						itemsLength: this.items.length,
					});
					break;
				}
				// biome-ignore lint/style/noNonNullAssertion: Array bounds checked in loop condition
				const result = await compareCallback(this.items[i]!, this.items[j]!);

				if (result <= -0.5) {
					// biome-ignore lint/style/noNonNullAssertion: Array bounds checked in loop condition
					merged.push(this.items[i++]!);
				} else if (result >= 0.5) {
					// biome-ignore lint/style/noNonNullAssertion: Array bounds checked in loop condition
					merged.push(this.items[j++]!);
				} else if (result < 0) {
					// biome-ignore lint/style/noNonNullAssertion: Array bounds checked in loop condition
					merged.push(this.items[i++]!);
					// biome-ignore lint/style/noNonNullAssertion: Array bounds checked in loop condition
					merged.push(this.items[j++]!);
				} else {
					// biome-ignore lint/style/noNonNullAssertion: Array bounds checked in loop condition
					merged.push(this.items[j++]!);
					// biome-ignore lint/style/noNonNullAssertion: Array bounds checked in loop condition
					merged.push(this.items[i++]!);
				}
			} catch (error) {
				console.error("Comparison failed:", error);
				// Handle cancellation or fallback strategy
			}
		}

		while (i <= mid) {
			// biome-ignore lint/style/noNonNullAssertion: Loop condition ensures valid index
			merged.push(this.items[i++]!);
		}
		while (j <= right) {
			// biome-ignore lint/style/noNonNullAssertion: Loop condition ensures valid index
			merged.push(this.items[j++]!);
		}

		for (let k = 0; k < merged.length; k++) {
			// biome-ignore lint/style/noNonNullAssertion: Array access within bounds of merged.length
			this.items[left + k] = merged[k]!;
			// biome-ignore lint/style/noNonNullAssertion: Array access within bounds of merged.length
			this.currentRankings[left + k] = merged[k]!;
		}

		if (left === 0 && right === this.items.length - 1) {
			this.ranks = [...merged];
		}
	}

	// Helper to get pair at a specific index without generating all pairs
	// Mapped from linear index k to (i, j)
	// This approach avoids O(N^2) memory but is O(N) to seek (if done naively),
	// but here we just iterate linearly in the loops below.
	// For random access by index, we can use the formula, but we don't strictly need random access,
	// just iteration from currentIndex.

	// Return the next un-judged pair as a match { left, right }
	getNextMatch(
		options: {
			ratings?: Record<string, { rating: number; wins?: number; losses?: number }>;
			comparisons?: Map<string, number>;
		} = {},
	): { left: string; right: string } | null {
		const { ratings = {}, comparisons = new Map() } = options;
		const n = this.items.length;

		// If we have ratings/comparisons, use adaptive selection
		if (Object.keys(ratings).length > 0 || comparisons.size > 0) {
			let bestPair: [string, string] | null = null;
			let bestScore = Infinity;
			let bestIndex = -1;

			// Virtual iteration starting from currentIndex
			let counter = 0;
			for (let i = 0; i < n - 1; i++) {
				for (let j = i + 1; j < n; j++) {
					if (counter >= this.currentIndex) {
						// Only process if after current index
						const a = this.getName(this.items[i]);
						const b = this.getName(this.items[j]);

						// Skip if already judged
						if (!this.preferences.has(`${a}-${b}`) && !this.preferences.has(`${b}-${a}`)) {
							// Adaptive scoring
							const ra = ratings[a]?.rating ?? 1500;
							const rb = ratings[b]?.rating ?? 1500;
							const diff = Math.abs(ra - rb);

							const ca = comparisons.get(a) || 0;
							const cb = comparisons.get(b) || 0;
							const uncScore = 1 / (1 + ca) + 1 / (1 + cb);

							// Diff is primary, uncertainty (uncScore) is secondary boost
							const score = diff - 50 * uncScore;

							if (score < bestScore) {
								bestScore = score;
								bestPair = [a, b];
								bestIndex = counter;
							}
						}
					}
					counter++;
				}
			}

			if (bestPair) {
				const [a, b] = bestPair;
				this.currentIndex = bestIndex;
				return { left: a, right: b };
			}
		}

		// Fallback to sequential selection
		// Start iteration from current index logic
		let counter = 0;
		for (let i = 0; i < n - 1; i++) {
			for (let j = i + 1; j < n; j++) {
				if (counter >= this.currentIndex) {
					const a = this.getName(this.items[i]);
					const b = this.getName(this.items[j]);

					if (!this.preferences.has(`${a}-${b}`) && !this.preferences.has(`${b}-${a}`)) {
						// Found the next sequential pair
						this.currentIndex = counter;
						return { left: a, right: b };
					}
					// If already judged, just move past it
					// Effectively we could just increment currentIndex here if we wanted to
					// always be "at the next unjudged pair", but for now we follow the "seek" pattern
				}
				counter++;
			}
		}

		// If we exhausted everything
		this.currentIndex = this.totalPairs;
		return null;
	}

	// Undo last added preference
	undoLastPreference(): boolean {
		const last = this.history.pop();
		if (!last) {
			return false;
		}
		const key = `${last.a}-${last.b}`;
		const reverseKey = `${last.b}-${last.a}`;
		this.preferences.delete(key);
		this.preferences.delete(reverseKey);
		// Step back at least one index to revisit the undone pair if needed
		this.currentIndex = Math.max(0, this.currentIndex - 1);
		return true;
	}
}
/**
 * @module Tournament/config
 * @description Consolidated configuration and utilities for tournament features
 * Includes constants, image utilities, and tournament-specific helpers
 */

// ============================================================================
// Constants
// ============================================================================

/**
 * Absolute paths for better image loading compatibility
 */
export const CAT_IMAGES = [
	"/assets/images/bby-cat.GIF",
	"/assets/images/cat.gif",
	"/assets/images/IMG_4844.jpg",
	"/assets/images/IMG_4845.jpg",
	"/assets/images/IMG_4846.jpg",
	"/assets/images/IMG_4847.jpg",
	"/assets/images/IMG_5044.JPEG",
	"/assets/images/IMG_5071.JPG",
	"/assets/images/IMG_0778.jpg",
	"/assets/images/IMG_0779.jpg",
	"/assets/images/IMG_0865.jpg",
	"/assets/images/IMG_0884.jpg",
	"/assets/images/IMG_0923.jpg",
	"/assets/images/IMG_1116.jpg",
	"/assets/images/IMG_7205.jpg",
	"/assets/images/75209580524__60DCC26F-55A1-4EF8-A0B2-14E80A026A8D.jpg",
];

export const GALLERY_IMAGE_SIZES = "100vw";
export const LIGHTBOX_IMAGE_SIZES = "100vw";

export const FALLBACK_NAMES = [
	{
		id: "aaron",
		name: "aaron",
		description: "temporary fallback — backend offline",
	},
	{
		id: "fix",
		name: "fix",
		description: "temporary fallback — backend offline",
	},
	{
		id: "the",
		name: "the",
		description: "temporary fallback — backend offline",
	},
	{
		id: "site",
		name: "site",
		description: "temporary fallback — backend offline",
	},
];

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Pick a deterministic image for a given id.
 * Falls back to the first image when the list is empty.
 * @param {string|number} id
 * @param {string[]} imageList
 * @returns {string|undefined}
 */
export function getRandomCatImage(
	id: string | number,
	imageList: string[] = [],
): string | undefined {
	if (!Array.isArray(imageList) || imageList.length === 0) {
		return undefined;
	}

	const seed =
		typeof id === "string"
			? Array.from(id).reduce((acc, char) => acc + char.charCodeAt(0), 0)
			: Number(id) || 0;

	const index = Math.abs(seed) % imageList.length;
	return imageList[index];
}

/**
 * Deduplicate images by base filename (ignores extension).
 * Earlier occurrences win.
 * @param {string[]} images
 * @returns {string[]}
 */
export function deduplicateImages(images: string[] = []): string[] {
	const seen = new Set<string>();
	const unique: string[] = [];

	for (const image of images) {
		if (typeof image !== "string" || image.length === 0) {
			continue;
		}

		const base = image.replace(/\.[^./]+$/, "");
		if (seen.has(base)) {
			continue;
		}

		seen.add(base);
		unique.push(image);
	}

	return unique;
}
/**
 * Computes a new rating by blending an existing rating with a new position rating based on the number of matches played.
 *
 * @param existingRating The player's current rating.
 * @param newPositionRating The rating derived from the player's new position/performance.
 * @param matchesPlayed The number of matches the player has played.
 * @param maxMatches The maximum number of matches possible or considered for full confidence.
 * @returns The new computed rating, clamped between 1000 and 2000.
 */
export function computeRating(
	existingRating: number,
	newPositionRating: number,
	matchesPlayed: number,
	maxMatches: number,
): number {
	const safeMaxMatches = Math.max(1, maxMatches);
	// Clamp matchesPlayed to maxMatches to prevent logical inconsistencies
	const clampedMatchesPlayed = Math.min(matchesPlayed, safeMaxMatches);
	const blendFactor = Math.min(0.8, (clampedMatchesPlayed / safeMaxMatches) * 0.9);
	const newRating = Math.round(
		blendFactor * newPositionRating + (1 - blendFactor) * existingRating,
	);
	return Math.max(1000, Math.min(2000, newRating));
}

import { generatePairs } from "../../shared/utils";
import type { NameItem } from "../../types/components";

export interface Sorter {
	_pairs?: Array<[unknown, unknown]>;
	_pairIndex?: number;
	preferences?: Map<string, unknown>;
}

export function initializeSorterPairs(sorter: Sorter | null, nameList: NameItem[]): void {
	if (!sorter) {
		return;
	}
	if (!Array.isArray(sorter._pairs)) {
		const validNameList = Array.isArray(nameList) ? nameList : [];
		sorter._pairs = generatePairs(validNameList);
		sorter._pairIndex = 0;
	}
}

export function getPreferencesMap(sorter: Sorter): Map<string, unknown> {
	return sorter.preferences instanceof Map ? sorter.preferences : new Map();
}

export function calculateMaxRoundForNames(namesCount: number): number {
	let maxRound = 1;
	let remainingNames = namesCount;

	while (remainingNames > 1) {
		const matchesThisRound = Math.floor(remainingNames / 2);
		const winners = matchesThisRound;
		const byes = remainingNames % 2;
		remainingNames = winners + byes;
		maxRound++;
	}

	return maxRound;
}

export function calculateBracketRound(namesCount: number, matchNumber: number): number {
	if (!Number.isInteger(namesCount) || namesCount < 1) {
		return 1;
	}
	if (!Number.isInteger(matchNumber) || matchNumber < 1) {
		return 1;
	}

	const maxMatches = namesCount - 1;
	if (matchNumber > maxMatches) {
		return calculateMaxRoundForNames(namesCount);
	}

	if (namesCount === 2) {
		return 1;
	}

	let roundNumber = 1;
	let remainingNames = namesCount;
	let matchesPlayed = 0;
	const maxRounds = Math.ceil(Math.log2(namesCount)) + 1;

	while (matchesPlayed < matchNumber - 1 && roundNumber < maxRounds) {
		const matchesThisRound = Math.floor(remainingNames / 2);

		if (matchesPlayed + matchesThisRound >= matchNumber) {
			break;
		}

		matchesPlayed += matchesThisRound;
		const winners = matchesThisRound;
		const byes = remainingNames % 2;
		remainingNames = winners + byes;
		roundNumber++;
	}

	return roundNumber;
}

export interface ComparisonHistory {
	winner: string;
	loser: string;
}

// * Build a comparisons map from tournament history
export function buildComparisonsMap(history: ComparisonHistory[]): Map<string, number> {
	const comparisons = new Map<string, number>();

	for (const { winner, loser } of history) {
		const pair = [winner, loser].sort().join(":");
		comparisons.set(pair, (comparisons.get(pair) || 0) + 1);
	}

	return comparisons;
}
